/*
Module: log-format-log4j
Description: Log Processing for Log4j
Docs: https://logging.apache.org/log4j/2.x/manual/layouts.html#json-template-layout
      https://github.com/logstash/log4j-jsonevent-layout
Arguments:
  forward_to: Module to forward the output to
*/
argument "forward_to" {
  optional = false
}

export "process" {
  value = loki.process.log_format_log4j
}

loki.process "log_format_log4j" {
  forward_to = [argument.forward_to.value]

  // check logs.agent.grafana.com/log-format annotation, if set to log4j-json then process the line as log4j-json
  stage.match {
    pipeline_name = "pipeline for annotation || logs.agent.grafana.com/log-format: log4j-json"
    selector = "{logs_agent_grafana_com_log_format=~\"(?i)log4j-?json\"}"

    stage.json {
      expressions = {
        level = "level",
        thread = "thread_name",
        logger = "logger_name",
        class = "class",
        timestamp = "[\"@timestamp\"]",
      }
    }

    // set the extracted values as labels so they can be used by downstream components, most likely several labels
    // will be dropped before being written to Loki
    stage.labels {
      values = {
        level = "",
        thread = "",
        logger = "",
        class = "",
        timestamp = "",
      }
    }

    // check logs.agent.grafana.com/scrub-timestamp annotation, if true remove the timestamp from the log line
    // this can reduce the overall # of bytes sent and stored in Loki
    // remove timestamp from the log line, depending on the entry it can be "start_time" or "time"
    stage.match {
      selector = "{logs_agent_grafana_com_scrub_timestamp=\"true\"}"
      pipeline_name = "pipeline for annotation || logs.agent.grafana.com/scrub-timestamp: true"

      // remove timestamp from the log line
      // unescaped regex: (?i)("@?timestamp"\s*:\s*"[^"]+",)
      stage.replace {
        expression = "(?i)(\"@?timestamp\"\\s*:\\s*\"[^\"]+\",)"
        replace = ""
      }
    }

    // check logs.agent.grafana.com/scrub-level annotation, if true remove the level from the log line (it is still a label)
    // this can reduce the overall # of bytes sent and stored in Loki
    stage.match {
      selector = "{logs_agent_grafana_com_scrub_level=~\"(?i)true\"}"
      pipeline_name = "pipeline for annotation || logs.agent.grafana.com/scrub-level: true"

      // remove level from the log line
      stage.replace {
        // unescaped regex: ("level"\s*:\s*"[^"]+",)
        expression = "(\"level\"\\s*:\\s*\"[^\"]+\",)"
        replace = ""
      }
    }

    // check logs.agent.grafana.com/scrub-nulls annotation, if true remove any json property whose value is set to null
    // this can reduce the overall # of bytes sent and stored in Loki
    stage.match {
      selector = "{logs_agent_grafana_com_scrub_nulls=~\"(?i)true\"}"
      pipeline_name = "pipeline for annotation || logs.agent.grafana.com/scrub-null: true"

      // remove null properties
      stage.replace {
        // unescaped regex: (,("[^"]+"\s*:\s*null)|("[^"]+"\s*:\s*null),)
        expression = "(,(\"[^\"]+\"\\s*:\\s*null)|(\"[^\"]+\"\\s*:\\s*null),)"
        replace = ""
      }
    }

    // check logs.agent.grafana.com/embed-pod annotation, if true embed the name of the pod to the end of the log line
    // this can reduce the overall cardinality, by not using a label of "pod", individual pods can still be searched
    // using a line selector i.e. __pod=your-pod-name
    stage.match {
      selector = "{logs_agent_grafana_com_embed_pod=~\"(?i)true\"}"
      pipeline_name = "pipeline for annotation || logs.agent.grafana.com/embed-pod: true"

      // render a new label called log_line, and add the name of the pod to the end of the log message
      // knowing the pod name can be valuable for debugging, but it should not be a label in Loki due
      // to the high cardinality it would create.
      // note: .Entry is a special key that is used to reference the current line
      stage.replace {
        expression = "\\}$"
        replace = ""
      }
      stage.template {
        source = "log_line"
        template = "{{ .Entry }},\"__pod\":\"{{ .pod }}\"}"
      }

      // reset the output to the log_line
      stage.output {
        source = "log_line"
      }
    }

  }

  // check logs.agent.grafana.com/log-format annotation, if set to log4j-text then process the line as log4j-text
  stage.match {
    pipeline_name = "pipeline for annotation || logs.agent.grafana.com/log-format: log4j-text"
    selector = "{logs_agent_grafana_com_log_format=~\"(?i)log4j(-?te?xt)?\"}"

    // extract the timestamp, level, traceId, spanId, processId, thread, logger from the log line
    stage.regex {
      // unescaped regex: (?P<timestamp>[0-9]{4}-[0-9]{2}-[0-9]{2}(T|\s+)[0-9]{2}:[0-9]{2}:[0-9]{2}(\.[0-9]+)?(Z|(\+|-)[0-9]+)?)\s+(?P<level>\w+)\s+\[(?P<thread>[^]]+)\]
      expression = "(?P<timestamp>[0-9]{4}-[0-9]{2}-[0-9]{2}(T|\\s+)[0-9]{2}:[0-9]{2}:[0-9]{2}(\\.[0-9]+)?(Z|(\\+|-)[0-9]+)?)\\s+(?P<level>\\w+)\\s+\\[(?P<thread>[^]]+)\\]"
    }

    // set the extracted values as labels so they can be used by downstream components, most likely several labels
    // will be dropped before being written to Loki
    stage.labels {
      values = {
        level = "",
        thread = "",
      }
    }

    // check logs.agent.grafana.com/scrub-timestamp annotation, if true remove the timestamp from the log line
    // this can reduce the overall # of bytes sent and stored in Loki
    // remove timestamp from the log line, depending on the entry it can be "start_time" or "time"
    stage.match {
      selector = "{logs_agent_grafana_com_scrub_timestamp=\"true\"}"
      pipeline_name = "pipeline for annotation || logs.agent.grafana.com/scrub-timestamp: true"

      // remove timestamp from the log line
      // unescaped regex: ([0-9]{4}-[0-9]{2}-[0-9]{2}(T|\s+)[0-9]{2}:[0-9]{2}:[0-9]{2}(\.[0-9]+)?(Z|(\+|-)[0-9]+)?)
      stage.replace {
        expression = "([0-9]{4}-[0-9]{2}-[0-9]{2}(T|\\s+)[0-9]{2}:[0-9]{2}:[0-9]{2}(\\.[0-9]+)?(Z|(\\+|-)[0-9]+)?)"
        replace = ""
      }
    }

    // check logs.agent.grafana.com/scrub-level annotation, if true remove the level from the log line (it is still a label)
    // this can reduce the overall # of bytes sent and stored in Loki
    stage.match {
      selector = "{logs_agent_grafana_com_scrub_level=~\"(?i)true\"}"
      pipeline_name = "pipeline for annotation || logs.agent.grafana.com/scrub-level: true"

      // remove level from the log line
      stage.replace {
        // unescaped regex: (\[?(DEBUG|INFO|WARN|ERROR|FATAL|TRACE)\]\s*)
        expression = "(\\[?(DEBUG|INFO|WARN|ERROR|FATAL|TRACE)\\]\\s*)"
        replace = ""
      }
    }

    // check logs.agent.grafana.com/embed-pod annotation, if true embed the name of the pod to the end of the log line
    // this can reduce the overall cardinality, by not using a label of "pod", individual pods can still be searched
    // using a line selector i.e. __pod=your-pod-name
    stage.match {
      selector = "{logs_agent_grafana_com_embed_pod=~\"(?i)true\"}"
      pipeline_name = "pipeline for annotation || logs.agent.grafana.com/embed-pod: true"

      // render a new label called log_line, and add the name of the pod to the end of the log message
      // knowing the pod name can be valuable for debugging, but it should not be a label in Loki due
      // to the high cardinality it would create.
      // note: .Entry is a special key that is used to reference the current line
      stage.template {
        source = "log_line"
        template = "{{ .Entry }} __pod={{ .pod }}"
      }

      // reset the output to the log_line
      stage.output {
        source = "log_line"
      }
    }

  }

}
